`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Company: 
// Engineer: 
// 
// Create Date:    16:00:53 01/21/2014 
// Design Name: 
// Module Name:    FX3_IF 
// Project Name: 
// Target Devices: 
// Tool versions: 
// Description: 
//
// Dependencies: 
//
// Revision: 
// Revision 0.01 - File Created
// Additional Comments: 
//
//////////////////////////////////////////////////////////////////////////////////
module FX3_IF (
    inout wire [31:0] fx3_bus,
//    input wire fx3_rd, // will be generated by FPGA internally
//    input wire fx3_counten, // counter limit value is on the databus
    input wire fx3_wr,
    input wire fx3_oe,
    input wire fx3_cs,
//    input wire fx3_dma_rdy,
//    input wire fx3_aden,
//    input wire fx3_clk,  // FX3 generates user clock
    output wire fx3_clk,  // DDR memory interface generates user clock
    output reg fx3_rdy, // will be monitored by FPGA internally during READ
    output reg fx3_ack,
    output reg fx3_rd_finish,		
    input wire fx3_rst,
    input wire [31:0] DataOut, // data from FPGA core
(* IOB = "FORCE" *) output reg [31:0] DataIn,  // data to FPGA core, force IOB register
    output reg WR,
    output reg RD,
    input FLAG1,
    input wire FLAG2,
    output reg FLAG1_reg,
    output reg FLAG2_reg,
    output reg [31:0] Addr,
    input wire RDY_N,
    input wire RD_VALID_N,
//		output wire CLK_100MHz,  // FX3 generates user clock
		input  wire CLK_100MHz,  // DDR memory interface generates user clock
		output wire RST,
//    output reg DMA_RDY,
    output reg CS
   );

genvar gen;

reg  [31:0] DATA_MISO; // master in slave out  FPGA -> FX3, registered
wire [31:0] DATA_MOSI; // master out slave in   FX3 -> FPGA
//reg  AddrEnable;
//reg  CountEnable;
reg  [31:0] ReqCountLimit;
reg  [31:0] ReqCount;
reg  flag;
reg  OE;
//reg  CS;
//reg DMA_RDY;
reg  [31:0] ValidCount;

parameter IDLE        = 8'b00000001;
parameter IN_ADDR     = 8'b00000010;
parameter WR_ADDR_INC = 8'b00000100;
parameter IN_COUNT    = 8'b00001000;
parameter NOP         = 8'b00010000;
parameter RD_ADDR_INC = 8'b00100000;
parameter RD_WAIT     = 8'b01000000;
parameter WAIT        = 8'b10000000;

reg [7:0] state = IDLE;

assign RST = fx3_rst;
//PULLUP rdy_n_pu_inst(.O(RDY_N));  // use pull-down to define RDYB signal if not driven
//PULLUP rd_valid_pu_inst(.O(RD_VALID_N));  // use pull-down to define RDYB signal if not driven
                                // RDY must be inverted because interconnect ressources only provides pull-down

//// clock buffer
//IBUFG #(
//      .IBUF_LOW_PWR("TRUE"),  // Low power (TRUE) vs. performance (FALSE) setting for referenced I/O standards 
//      .IOSTANDARD("DEFAULT")  // Specify the input I/O standard
//   ) IBUFG_inst (
//      .O(CLK_100MHz), // Clock buffer output
//      .I(fx3_clk)  // Clock buffer input (connect directly to top-level port)
//);

// drive clock out to FX3
   ODDR #(
      .DDR_CLK_EDGE("OPPOSITE_EDGE"), // "OPPOSITE_EDGE" or "SAME_EDGE" 
      .INIT(1'b0),    // Initial value of Q: 1'b0 or 1'b1
      .SRTYPE("SYNC") // Set/Reset type: "SYNC" or "ASYNC" 
   ) fx3_clk_reg_inst (
      .Q(fx3_clk),   // 1-bit DDR output
      .C(CLK_100MHz), // 1-bit clock input
      .CE(1'b1),    // 1-bit clock enable input
      .D1(1'b0), // 1-bit data input (positive edge)
      .D2(1'b1), // 1-bit data input (negative edge)
      .R(1'b0), // 1-bit reset
      .S(1'b0) // 1-bit set
   );



// output register
always @ (posedge CLK_100MHz)
begin 
 	fx3_ack <= !RD_VALID_N;
	fx3_rdy <= !RDY_N; 
	DATA_MISO <= DataOut;
end

// input register
always @ (posedge CLK_100MHz)
begin 
//  RD <= fx3_rd; // will be generated by FPGA internally
 	WR <= fx3_wr;
 	OE <= fx3_oe;
 	CS <= fx3_cs;
// 	DMA_RDY <= fx3_dma_rdy;
//	AddrEnable <= fx3_aden;
//	CountEnable <= fx3_counten;
	DataIn <= DATA_MOSI;
	
	FLAG1_reg <= FLAG1;
    FLAG2_reg <= FLAG2;
end

always @ (posedge	CLK_100MHz or posedge fx3_rst)
begin
  if (fx3_rst) 
  begin
    ValidCount <= 32'd0;
    fx3_rd_finish <= 0;
  end
  else
  begin
    if ((ValidCount == ReqCountLimit) /*& (ReqCountLimit != 0)*/)
    begin
      fx3_rd_finish <= 1;
      ValidCount <= 32'd0;
    end
    else if (FLAG2_reg & (!RD_VALID_N) /*& (ValidCount != ReqCountLimit)*/)
    begin
      fx3_rd_finish <= 0;
      ValidCount <= ValidCount + 1;
    end
  end
end

// address latch & counter for memory access
always @ (posedge	CLK_100MHz or posedge fx3_rst)  // latch address and increment for memory IO (Addr[31] == 1)
begin
  if (fx3_rst) 
  begin
    state <= IDLE;
    Addr <= 32'd0;
    ReqCountLimit <= 32'd0;
    ReqCount <= 32'd0;
    RD <= 0;
  end
  else
     case (state)
        IDLE : begin
           //ReqCountLimit <= 32'd0;
           ReqCount <= 32'd0;
           RD <= 0;
           if (CS & !OE) // !OE is needed to prevent entering IN_ADDR second time after read request is finished 
           begin
              state <= IN_ADDR;
           end
           /*else if (!CS & !OE)
           begin
              state <= IDLE;
           end*/
           else
              state <= IDLE;
        end
        IN_ADDR : begin
           Addr <= DataIn[31:0];
           state <= IN_COUNT;
        end
        WR_ADDR_INC : begin
           if (WR)
           begin
              state <= WR_ADDR_INC;
              Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
           end
           else if (!CS)
              state <= IDLE;
           else
              state <= WAIT;
        end
        IN_COUNT : begin
           ReqCountLimit <= (DataIn[31:0] / 4);
           if (!RDY_N & OE & /*DMA_RDY*/FLAG2_reg)
           begin
              state <= RD_ADDR_INC;
              RD <= 1;
           end
           else if (WR)
           begin
              state <= WR_ADDR_INC;
              Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
           end
           else
              state <= WAIT;
        end
        NOP : begin
           state <= IDLE;
           /*RD <= 1;
           state <= RD_ADDR_INC;*/ // add 1 addr_inc here?
           /*Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
           ReqCount <= ReqCount + 1;*/
        end
        RD_ADDR_INC : begin
           if (!RDY_N & OE & (ReqCount != (ReqCountLimit-1)) & /*DMA_RDY*/FLAG2_reg)
           begin
              state <= RD_ADDR_INC;
              Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
              ReqCount <= ReqCount + 1;
              RD <= 1;
           end
           else if (ReqCount == (ReqCountLimit-1))
           begin
              state <= IDLE;
              RD <= 0;
           end
           else
           begin
              state <= RD_WAIT;
              RD <= 0;
           end       
        end
        RD_WAIT : begin
           if (!RDY_N & OE & (ReqCount != (ReqCountLimit-1)) & /*DMA_RDY*/FLAG2_reg)
           begin
              state <= RD_ADDR_INC; // add 1 addr_inc here?
              Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
              ReqCount <= ReqCount + 1;
              RD <= 1;
           end
           else if (ReqCount == (ReqCountLimit-1))
           begin
              state <= IDLE;
              RD <= 0;
           end
           else
           begin
              state <= RD_WAIT;
              RD <= 0;
           end
        end
        WAIT : begin
           if (!RDY_N & OE & /*DMA_RDY*/FLAG2_reg)
           begin
              state <= RD_ADDR_INC;
              RD <= 1;
           end
           else if (WR)
           begin
              state <= WR_ADDR_INC; // add 1 addr_inc here?
              Addr[30:0] <= Addr[30:0] + 1;  // keep Addr[31]
           end
           else if (!CS)
              state <= IDLE;
           else 
              state <= WAIT;
        end
        default : begin  // Fault Recovery
           state <= IDLE;
        end   
     endcase
end

// tristate buffer for bus
generate
for (gen = 0; gen < 32; gen = gen + 1) 
	begin : tri_buf // 32 bit databus
		IOBUF #(
			.DRIVE(12), // Specify the output drive strength
			.IBUF_LOW_PWR("FALSE"),  // Low Power - "TRUE", High Performance = "FALSE" 
			.IOSTANDARD("LVCMOS33"), // Specify the I/O standard !!!!!!!!!!!!!!!!!!!!!!
			.SLEW("FAST") // Specify the output slew rate
		) IOBUF_inst (
			.O(DATA_MOSI[gen]),     // Buffer output
			.IO(fx3_bus[gen]),   // Buffer inout port (connect directly to top-level port)
			.I(DATA_MISO[gen]),     // Buffer input
			.T(!(fx3_oe & fx3_cs))      // 3-state enable input, high=input, low=output
		);
	end
endgenerate

endmodule
